/*
 * Copyright (c) 2020 ARM Limited
 * All rights reserved
 *
 * The license below extends only to copyright in the software and shall
 * not be construed as granting a license to any other intellectual
 * property including but not limited to intellectual property relating
 * to a hardware implementation of the functionality of the software
 * licensed hereunder.  You may use the software subject to the license
 * terms below provided that you ensure that this notice is replicated
 * unmodified and in its entirety in all distributions of the software,
 * modified or unmodified, in source code or in binary form.
 *
 * Copyright (c) 1999-2013 Mark D. Hill and David A. Wood
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met: redistributions of source code must retain the above copyright
 * notice, this list of conditions and the following disclaimer;
 * redistributions in binary form must reproduce the above copyright
 * notice, this list of conditions and the following disclaimer in the
 * documentation and/or other materials provided with the distribution;
 * neither the name of the copyright holders nor the names of its
 * contributors may be used to endorse or promote products derived from
 * this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

machine(MachineType:L1Cache, "MESI Directory L1 Cache CMP")
 :
   // FalseSharing: Accepts memory requests from other objects and converts to a RubyRequest
   Sequencer * sequencer;
   CacheMemory * L1Icache;
   CacheMemory * L1Dcache;
   RubyPrefetcher * prefetcher;
   FSOptionalPerCoreState * OptionalOwnAccessMetadata; // FalseSharing:  own access metadata
   // FSEvictionMDCache * EvictionMDEntries; // FalseSharing: handle ack for MD sent on eviction
   int l2_select_num_bits;
   Cycles l1_request_latency := 2;
   Cycles l1_response_latency := 2;
   Cycles to_l2_latency := 1;
   bool send_evictions;
   bool enable_prefetch := "False";
   bool report_pc := "False";
   // Message Queues
   // From this node's L1 cache TO the network

   // FalseSharing: Higher number means higher priority
   // a local L1 -> this L2 bank, currently ordered with directory forwarded requests
   MessageBuffer * requestFromL1Cache, network="To", virtual_network="0",
        vnet_type="request";

   // a local L1 -> this L2 bank
   MessageBuffer * responseFromL1Cache, network="To", virtual_network="1",
        vnet_type="response";

   MessageBuffer * unblockFromL1Cache, network="To", virtual_network="2",
        vnet_type="unblock";


   // To this node's L1 cache FROM the network
   // a L2 bank -> this L1
   MessageBuffer * requestToL1Cache, network="From", virtual_network="2",
        vnet_type="request";

   // a L2 bank -> this L1
   MessageBuffer * responseToL1Cache, network="From", virtual_network="1",
        vnet_type="response";

  // Request Buffer for prefetches
  MessageBuffer * optionalQueue;

  // FalseSharing: does not connect to the Ruby network, used by the Sequencer to convert gem5
  // packets to RubyRequest
  // Buffer for requests generated by the processor core.
  MessageBuffer * mandatoryQueue;
{
  // STATES
  state_declaration(State, desc="Cache states", default="L1Cache_State_I") {
    // Base states
    NP, AccessPermission:Invalid, desc="Not present in either cache";
    I, AccessPermission:Invalid, desc="a L1 cache entry Idle";
    S, AccessPermission:Read_Only, desc="a L1 cache entry Shared";
    E, AccessPermission:Read_Only, desc="a L1 cache entry Exclusive";
    M, AccessPermission:Read_Write, desc="a L1 cache entry Modified", format="!b";

    // Transient States
    IS, AccessPermission:Busy, desc="L1 idle, issued GETS, have not seen response yet";
    IM, AccessPermission:Busy, desc="L1 idle, issued GETX, have not seen response yet";
    SM, AccessPermission:Read_Only, desc="L1 idle, issued GETX, have not seen response yet";
    IS_I, AccessPermission:Busy, desc="L1 idle, issued GETS, saw Inv before data because directory doesn't block on GETS hit";

    M_I, AccessPermission:Busy, desc="L1 replacing, waiting for ACK";
    SINK_WB_ACK, AccessPermission:Busy, desc="This is to sink WB_Acks from L2";

    // Transient States in which block is being prefetched
    PF_IS, AccessPermission:Busy, desc="Issued GETS, have not seen response yet";
    PF_IM, AccessPermission:Busy, desc="Issued GETX, have not seen response yet";
    PF_SM, AccessPermission:Busy, desc="Issued GETX, received data, waiting for acks";
    PF_IS_I, AccessPermission:Busy, desc="Issued GETs, saw inv before data";

    // FalseSharing: New stable state to mark block private
    PRV, AccessPermission:Read_Write, desc="Blocked marked PRV";
    PRV_IB, AccessPermission:Busy, desc="Block transitioning in to /out from PRV";
    PRV_CHK_ST, AccessPermission:Busy, desc="Block waiting for conflict ack from LLC on ST to a new byte";
    PRV_CHK_LD, AccessPermission:Busy, desc="Block waiting for conflict ack from LLC on LD to a new byte";
    SM_P, AccessPermission:Busy, desc="Block waiting for ack or termination of privatization";
    PRV_IBW, AccessPermission:Busy, desc="Block waiting for acknowledgement after receiving invalidation for private block";
    IS_PRV, AccessPermission:Busy, desc="The intiate privatization arrives before GetS response";
    IM_PRV, AccessPermission:Busy, desc="The intiate privatization arrives before GetX response";
    IM_RTRY, AccessPermission:Busy, desc="The WB ack on termination receive for block, retry the store";
    IM_PAA, AccessPermission:Busy, desc="Receive termination request for block while UPGARDE request is inflight";
    IM_PD, AccessPermission:Busy, desc="Waiting for Data resposne for block on termination of privatization";
    IM_I, AccessPermission:Busy, desc="The WB ack arrives for the block, waiting for Data privatization";
    S_I, AccessPermission:Busy, desc="L1 replacing, waiting for eviction MD ACK";
    IM_PR, AccessPermission:Busy, desc="Privatization termination, issue a store";
    IM_PA, AccessPermission:Busy, desc="Privatization termination, ack for WB, wait for data block or conflict ack";
    IS_PR, AccessPermission:Busy, desc="Privatization termination, issue a load";
    IS_PA, AccessPermission:Busy, desc="Privatization termination, ack for WB, wait for data block or conflict ack";
    IS_RTRY, AccessPermission:Busy, desc="The WB ack on termination receive for block, retry the store";
    IS_PD, AccessPermission:Busy, desc="Waiting for WB ack for block on termination of privatization";
    IS_PDI, AccessPermission:Busy, desc="Waiting for Data resposne for block on termination of privatization, WB ack arrived";
  }

  // EVENTS
  enumeration(Event, desc="Cache events") {
    // L1 events
    Load,            desc="Load request from the home processor";
    Ifetch,          desc="I-fetch request from the home processor";
    Store,           desc="Store request from the home processor";

    Inv,           desc="Invalidate request from L2 bank";

    // internal generated request
    L1_Replacement,  desc="L1 Replacement", format="!r";
    PF_L1_Replacement,  desc="Prefetch L1 Replacement", format="!pr";
    L1_Replacement_S,  desc="L1 Replacement for S state and eviction metadata required", format="!rs";

    // other requests
    Fwd_GETX,   desc="GETX from other processor";
    Fwd_GETS,   desc="GETS from other processor";
    Fwd_GET_INSTR,   desc="GET_INSTR from other processor";

    Data,       desc="Data for processor";
    Data_Exclusive,       desc="Data for processor";
    DataS_fromL1,       desc="data for GETS request, need to unblock directory";
    Data_all_Acks,       desc="Data for processor, all acks";

    Ack,        desc="Ack for processor";
    Ack_all,      desc="Last ack for processor";

    WB_Ack,        desc="Ack for replacement";

    PF_Load,    desc="load request from prefetcher";
    PF_Ifetch,  desc="instruction fetch request from prefetcher";
    PF_Store,   desc="exclusive load request from prefetcher";

    // FalseSharing: additional event to handle forwarded request in SM/IM state
    Pen_GetX, desc="Last ack for processor and a outstanding getX";
    Pen_GetS, desc="Last ack for processor and a outstanding getS";
    Data_all_Acks_Unblock, desc="Data for processor, all acks, send unblock"; // FalseSharing: Prv cache response, MT>MT_MB
    TR_PRV, desc="Received a PRV Ack, mark block PRV"; // FalseSharing: L2 send PRV ack for block
    Data_PRV, desc="received data block for a private cache line"; //Possible only for state IM, IS
    CH_PRV_ST, desc="First LD/ST to byte, check with directory for conflict";
    CH_PRV_LD, desc="First LD/ST to byte, check with directory for conflict";
    NC_PRV, desc="LLC does not detect a conflict, carry on with ST/LD";
    
    RMW_Read_Store, desc="A store for RMW_read"; // FalseSharing:
    RMW_Write_Store, desc="A store for RMW_write, but no pending request"; // FalseSharing:
    Write_Store_PenX, desc="Store for RMW write, pending getx request to service"; // FalseSharing:
    Write_Store_PenS, desc="Store for RMW write, pending gets request to service"; // FalseSharing:
    Data_all_Acks_RMW, desc="RMW_read store";
    Data_all_Acks_Unblock_RMW, desc="RMW_read store unblock";
    Ack_all_RMW, desc="Unblock RMW store";
    Inv_TR, desc="terminating privatization, received invalidation before the conflict request ack";
    Ack_EMD, desc="ACK for eviction MD message arrives, deallocate entry";
    Inv_PRV, desc="invalidate copy of private block, respond with data block";
  }

  // TYPES

  // CacheEntry
  structure(Entry, desc="...", interface="AbstractCacheEntry" ) {
    State CacheState,        desc="cache state";
    DataBlock DataBlk,       desc="data for the block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch, desc="Set if this block was prefetched and not yet accessed";
    bool isPrivatized, desc="Set if block is privatizated"; //FalseSharing: bit for private block
    //bool requireMetadata, default="false", desc="send metadata if bit is set";
  }

  // TBE fields
  structure(TBE, desc="...") {
    Addr addr,              desc="Physical address for this TBE";
    State TBEState,        desc="Transient state";
    DataBlock DataBlk,                desc="Buffer for the data block";
    bool Dirty, default="false",   desc="data is dirty";
    bool isPrefetch,       desc="Set if this was caused by a prefetch";
    int pendingAcks, default="0", desc="number of pending acks";
    // FalseSharing:
    int bytesCount, default="1", desc="number of bytes accessed";
    Addr PhyAddress, desc="addr requested by core";
    
    // Required for reissue of request
    RubyAccessMode AccessMode,    desc="user/supervisor access type";
    PrefetchBit Prefetch, desc="whether a prefetching request or not";
    // FalseSharing: to handle forwarded request in SM/IM
    bool pendingRequest, desc="if any pending request available";
    MachineID pendingRequestor, desc="pending requestor";
    CoherenceRequestType pendingReqType, desc= "type of request";
    // FalseSharing: flag to differentiate if store is issued corresponding to RMW_Read
    bool isRMW_Read, default="false", desc="whether store is RMW_Read" ;

    // FalseSharing: a new bit to identify MD action for forwarded request
    bool metadataAction, default="false", desc="decide whether to send metadata or not";
    //bool evictionMD, deafult="false", desc="track the ack for MD sent on eviction";
  }

  structure(TBETable, external="yes") {
    TBE lookup(Addr);
    void allocate(Addr);
    void deallocate(Addr);
    bool isPresent(Addr);
  }

  TBETable TBEs, template="<L1Cache_TBE>", constructor="m_number_of_TBEs";

  int l2_select_low_bit, default="RubySystem::getBlockSizeBits()";

  Tick clockEdge();
  Cycles ticksToCycles(Tick t);
  void set_cache_entry(AbstractCacheEntry a);
  void unset_cache_entry();
  void set_tbe(TBE a);
  void unset_tbe();
  void wakeUpBuffers(Addr a);
  void profileMsgDelay(int virtualNetworkType, Cycles c);

  // inclusive cache returns L1 entries only
  Entry getCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    if(is_valid(L1Dcache_entry)) {
      return L1Dcache_entry;
    }

    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  Entry getL1DCacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Dcache_entry := static_cast(Entry, "pointer", L1Dcache[addr]);
    return L1Dcache_entry;
  }

  Entry getL1ICacheEntry(Addr addr), return_by_pointer="yes" {
    Entry L1Icache_entry := static_cast(Entry, "pointer", L1Icache[addr]);
    return L1Icache_entry;
  }

  State getState(TBE tbe, Entry cache_entry, Addr addr) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    if(is_valid(tbe)) {
      return tbe.TBEState;
    } else if (is_valid(cache_entry)) {
      return cache_entry.CacheState;
    }
    return State:NP;
  }

  void setState(TBE tbe, Entry cache_entry, Addr addr, State state) {
    assert((L1Dcache.isTagPresent(addr) && L1Icache.isTagPresent(addr)) == false);

    // MUST CHANGE
    if(is_valid(tbe)) {
      tbe.TBEState := state;
    }

    if (is_valid(cache_entry)) {
      cache_entry.CacheState := state;
    }
  }

  AccessPermission getAccessPermission(Addr addr) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(tbe.TBEState));
      return L1Cache_State_to_permission(tbe.TBEState);
    }

    Entry cache_entry := getCacheEntry(addr);
    if(is_valid(cache_entry)) {
      DPRINTF(RubySlicc, "%s\n", L1Cache_State_to_permission(cache_entry.CacheState));
      return L1Cache_State_to_permission(cache_entry.CacheState);
    }

    DPRINTF(RubySlicc, "%s\n", AccessPermission:NotPresent);
    return AccessPermission:NotPresent;
  }

  void functionalRead(Addr addr, Packet *pkt) {
    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      testAndRead(addr, tbe.DataBlk, pkt);
    } else {
      testAndRead(addr, getCacheEntry(addr).DataBlk, pkt);
    }
  }

  int functionalWrite(Addr addr, Packet *pkt) {
    int num_functional_writes := 0;

    TBE tbe := TBEs[addr];
    if(is_valid(tbe)) {
      num_functional_writes := num_functional_writes +
        testAndWrite(addr, tbe.DataBlk, pkt);
      return num_functional_writes;
    }

    num_functional_writes := num_functional_writes +
        testAndWrite(addr, getCacheEntry(addr).DataBlk, pkt);
    return num_functional_writes;
  }

  void setAccessPermission(Entry cache_entry, Addr addr, State state) {
    if (is_valid(cache_entry)) {
      cache_entry.changePermission(L1Cache_State_to_permission(state));
    }
  }

  Event mandatory_request_type_to_event(RubyRequestType type) {
    if (type == RubyRequestType:LD) {
      return Event:Load;
    } else if (type == RubyRequestType:IFETCH) {
      return Event:Ifetch;
    } else if ((type == RubyRequestType:ST) || (type == RubyRequestType:ATOMIC)) {
      return Event:Store;
    } else if (type == RubyRequestType:ST_RMW_Read) { // FalseSharing: diff a locked rmw read
      return Event:RMW_Read_Store;
    } else if (type == RubyRequestType:ST_RMW_Write) { // FalseSharing: diff a locked rmw write
      return Event:Store; // FalseSharing: RMW_Write_Store
    } else {
      error("Invalid RubyRequestType");
    }
  }

  Event prefetch_request_type_to_event(RubyRequestType type) {
      if (type == RubyRequestType:LD) {
          return Event:PF_Load;
      } else if (type == RubyRequestType:IFETCH) {
          return Event:PF_Ifetch;
      } else if ((type == RubyRequestType:ST) ||
                 (type == RubyRequestType:ATOMIC)) {
          return Event:PF_Store;
      } else {
          error("Invalid RubyRequestType");
      }
  }

  int getPendingAcks(TBE tbe) {
    return tbe.pendingAcks;
  }

  out_port(requestL1Network_out, RequestMsg, requestFromL1Cache);
  out_port(responseL1Network_out, ResponseMsg, responseFromL1Cache);
  out_port(unblockNetwork_out, ResponseMsg, unblockFromL1Cache);
  out_port(optionalQueue_out, RubyRequest, optionalQueue);


  // Prefetch queue between the controller and the prefetcher
  // As per Spracklen et al. (HPCA 2005), the prefetch queue should be
  // implemented as a LIFO structure.  The structure would allow for fast
  // searches of all entries in the queue, not just the head msg. All
  // msgs in the structure can be invalidated if a demand miss matches.
  in_port(optionalQueue_in, RubyRequest, optionalQueue, desc="...", rank = 3) {
      if (optionalQueue_in.isReady(clockEdge())) {
          peek(optionalQueue_in, RubyRequest) {
              // Instruction Prefetch
              if (in_msg.Type == RubyRequestType:IFETCH) {
                  Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Icache_entry)) {
                      // The block to be prefetched is already present in the
                      // cache. We should drop this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  }

                  // Check to see if it is in the OTHER L1
                  Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Dcache_entry)) {
                      // The block is in the wrong L1 cache. We should drop
                      // this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  }

                  if (L1Icache.cacheAvail(in_msg.LineAddress)) {
                      // L1 does't have the line, but we have space for it
                      // in the L1 so let's see if the L2 has it
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  } else {
                      // No room in the L1, so we need to make room in the L1
                      Addr victim := L1Icache.cacheProbe(in_msg.LineAddress);
                      trigger(Event:PF_L1_Replacement,
                              victim, getL1ICacheEntry(victim), TBEs[victim]);
                  }
              } else {
                  // data prefetch
                  Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Dcache_entry)) {
                      // The block to be prefetched is already present in the
                      // cache. We should drop this request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  }

                  // Check to see if it is in the OTHER L1
                  Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
                  if (is_valid(L1Icache_entry)) {
                      // The block is in the wrong L1. Just drop the prefetch
                      // request.
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Icache_entry, TBEs[in_msg.LineAddress]);
                  }

                  if (L1Dcache.cacheAvail(in_msg.LineAddress)) {
                      // L1 does't have the line, but we have space for it in
                      // the L1 let's see if the L2 has it
                      trigger(prefetch_request_type_to_event(in_msg.Type),
                              in_msg.LineAddress,
                              L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  } else {
                      // No room in the L1, so we need to make room in the L1
                      Addr victim := L1Dcache.cacheProbe(in_msg.LineAddress);
                      trigger(Event:PF_L1_Replacement,
                              victim, getL1DCacheEntry(victim), TBEs[victim]);
                  }
              }
          }
      }
  }

  // Response  L1 Network - response msg to this L1 cache
  in_port(responseL1Network_in, ResponseMsg, responseToL1Cache, rank = 2) {
    if (responseL1Network_in.isReady(clockEdge())) {
      peek(responseL1Network_in, ResponseMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];

        if(in_msg.Type == CoherenceResponseType:DATA_EXCLUSIVE) {
          // FalseSharing: Received excluvsive response
          // The forwarded request arrived before Exclusive response
          // Need to serve pending request 
          if(tbe.pendingRequest) {
            if(tbe.pendingReqType == CoherenceRequestType:GETX ||
                  tbe.pendingReqType == CoherenceRequestType:UPGRADE ||
                  tbe.pendingReqType == CoherenceRequestType:GA_CHCK_ST){
              trigger(Event:Pen_GetX, in_msg.addr, cache_entry, tbe);
            } else { // Handle GETS and get instruction 
              trigger(Event:Pen_GetS, in_msg.addr, cache_entry, tbe);
            }
          } else {
            trigger(Event:Data_Exclusive, in_msg.addr, cache_entry, tbe);
          }
        } else if(in_msg.Type == CoherenceResponseType:GA_DATA) {
          // Add a check if  have a RMW store 
          // FalseSharing: Mark block private, privatization initiated by LLC/Directory
          trigger(Event:Data_PRV, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Type == CoherenceResponseType:DATA) { // FalseSharing: Copy the REQ_MD bit to PAM
          if ((getState(tbe, cache_entry, in_msg.addr) == State:IS ||
               getState(tbe, cache_entry, in_msg.addr) == State:IS_I ||
               getState(tbe, cache_entry, in_msg.addr) == State:PF_IS ||
               getState(tbe, cache_entry, in_msg.addr) == State:PF_IS_I ||
               getState(tbe, cache_entry, in_msg.addr) == State:IS_PA) &&
              machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {

              trigger(Event:DataS_fromL1, in_msg.addr, cache_entry, tbe);

          } else if (is_valid(tbe) && (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            if(tbe.isRMW_Read) { 
              // FalseSharing: Allow store to complete
              if(machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {
                trigger(Event:Data_all_Acks_Unblock_RMW, in_msg.addr, cache_entry, tbe);
              } else { // FalseSharing: data response by Directory
                trigger(Event:Data_all_Acks_RMW, in_msg.addr, cache_entry, tbe);
              }
            } else if(tbe.pendingRequest) {
              tbe.pendingRequest := false;
              if(tbe.pendingReqType == CoherenceRequestType:GETX ||
                  tbe.pendingReqType == CoherenceRequestType:UPGRADE ||
                  tbe.pendingReqType == CoherenceRequestType:GA_CHCK_ST) {
                // FalseSharing: transition for GETX and UPGRADE
                trigger(Event:Pen_GetX, in_msg.addr, cache_entry, tbe);
              } else { // if(tbe.pendingReqType == CoherenceRequestType:GETS) 
                trigger(Event:Pen_GetS, in_msg.addr, cache_entry, tbe);
              }
            } else {
              // FalseSharing: check if data forwarded by L1 cache send unblock signal
              if(machineIDToMachineType(in_msg.Sender) == MachineType:L1Cache) {
                trigger(Event:Data_all_Acks_Unblock, in_msg.addr, cache_entry, tbe);
              } else { // FalseSharing: data send by Directory
                trigger(Event:Data_all_Acks, in_msg.addr, cache_entry, tbe);
              }
            }
          } else {
            trigger(Event:Data, in_msg.addr, cache_entry, tbe);
          }
        } else if (in_msg.Type == CoherenceResponseType:ACK) {
          if ( (getPendingAcks(tbe) - in_msg.AckCount) == 0 ) {
            if(tbe.isRMW_Read) { 
                trigger(Event:Ack_all_RMW, in_msg.addr, cache_entry, tbe);
            } else if(tbe.pendingRequest ) { // Commit the store and Handle pending request
              // FalseSharing: Reset the pendingRequest flag after serving the request
              // FalseSharing: not resetting the "pendingRequest" flag leads to incorrect
              // processing of future ack results in deadlock
              tbe.pendingRequest := false;
              if(tbe.pendingReqType == CoherenceRequestType:GETX ||
                  tbe.pendingReqType == CoherenceRequestType:UPGRADE ||
                  tbe.pendingReqType == CoherenceRequestType:GA_CHCK_ST) {
                // transition for GETX and UPGRADE
                trigger(Event:Pen_GetX, in_msg.addr, cache_entry, tbe);
              } else { // if(tbe.pendingReqType == CoherenceRequestType:GETS)
                // FalseSharing:
                trigger(Event:Pen_GetS, in_msg.addr, cache_entry, tbe);
              }
            } else {
              trigger(Event:Ack_all, in_msg.addr, cache_entry, tbe);
            }
          } else {
            trigger(Event:Ack, in_msg.addr, cache_entry, tbe);
          }
        } else if (in_msg.Type == CoherenceResponseType:WB_ACK) {
          trigger(Event:WB_Ack, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Type == CoherenceResponseType:GA_NC) {
          // FalseSharing:
          trigger(Event:NC_PRV, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Type == CoherenceResponseType:GA_CA) {
          // FalseSharing: termination in progress,
          trigger(Event:Inv_TR, in_msg.addr, cache_entry, tbe);
        } else if(in_msg.Type == CoherenceResponseType:EMD_ACK) {
          trigger(Event:Ack_EMD, in_msg.addr, cache_entry, tbe);
        } else {
          error("Invalid L1 response type");
        }
      }
    }
  }

  // Request InterChip network - request from this L1 cache to the shared L2
  in_port(requestL1Network_in, RequestMsg, requestToL1Cache, rank = 1) {
    if(requestL1Network_in.isReady(clockEdge())) {
      peek(requestL1Network_in, RequestMsg, block_on="addr") {
        assert(in_msg.Destination.isElement(machineID));

        Entry cache_entry := getCacheEntry(in_msg.addr);
        TBE tbe := TBEs[in_msg.addr];
        // FalseSharing: handle load/sotre check request
        if (in_msg.Type == CoherenceRequestType:INV) {
          trigger(Event:Inv, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:GETX ||
                   in_msg.Type == CoherenceRequestType:UPGRADE ||
                   in_msg.Type == CoherenceRequestType:GA_CHCK_ST) { // FalseSharing:
          // upgrade transforms to GETX due to race
          trigger(Event:Fwd_GETX, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:GETS ||
                  in_msg.Type == CoherenceRequestType:GA_CHCK_LD) {
          trigger(Event:Fwd_GETS, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:GET_INSTR) {
          trigger(Event:Fwd_GET_INSTR, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:GA_FRWD) {
          // FalseSharing: LLC privatizes a block, mark it private in local cache
          // FalseSharing: Send data to LLC
          // check for pending eviction MD ack if not recycle the message
          trigger(Event:TR_PRV, in_msg.addr, cache_entry, tbe);
        } else if (in_msg.Type == CoherenceRequestType:INV_PRV) {
          trigger(Event:Inv_PRV, in_msg.addr, cache_entry, tbe);
        } else {
          error("Invalid forwarded request type");
        }
      }
    }
  }

  // Mandatory Queue betweens Node's CPU and it's L1 caches
  in_port(mandatoryQueue_in, RubyRequest, mandatoryQueue, desc="...", rank = 0) {
    if (mandatoryQueue_in.isReady(clockEdge())) {
      peek(mandatoryQueue_in, RubyRequest, block_on="LineAddress") {

        // Check for data access to blocks in I-cache and ifetchs to blocks in D-cache

        if (in_msg.Type == RubyRequestType:IFETCH) {
          // ** INSTRUCTION ACCESS ***

          Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
          if (is_valid(L1Icache_entry)) {
            // The tag matches for the L1, so the L1 asks the L2 for it.
            trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
                    L1Icache_entry, TBEs[in_msg.LineAddress]);
          } else {

            // Check to see if it is in the OTHER L1
            Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
            if (is_valid(L1Dcache_entry)) {
              // The block is in the wrong L1, put the request on the queue to the shared L2
              trigger(Event:L1_Replacement, in_msg.LineAddress,
                      L1Dcache_entry, TBEs[in_msg.LineAddress]);
            }

            if (L1Icache.cacheAvail(in_msg.LineAddress)) {
              // L1 does't have the line, but we have space for it
              // in the L1 so let's see if the L2 has it.
              trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
                      L1Icache_entry, TBEs[in_msg.LineAddress]);
            } else {
              // No room in the L1, so we need to make room in the L1

              // Check if the line we want to evict is not locked
              Addr addr := L1Icache.cacheProbe(in_msg.LineAddress);
              check_on_cache_probe(mandatoryQueue_in, addr);

              trigger(Event:L1_Replacement, addr,
                      getL1ICacheEntry(addr),
                      TBEs[addr]);
            }
          }
        } else {

          // *** DATA ACCESS ***
          Entry L1Dcache_entry := getL1DCacheEntry(in_msg.LineAddress);
          TBE tbe := TBEs[in_msg.LineAddress];

          if (is_valid(L1Dcache_entry)) {
            // FalseSharing: check if first access to the byte in privatize state
            // FalseSharing: Private controller do not perform the detection to prevent the multiple inflight detection at other cores.
            if(getState(tbe, L1Dcache_entry, in_msg.LineAddress) == State:PRV &&
              OptionalOwnAccessMetadata.accessToNewBytes(in_msg.PhysicalAddress, in_msg.Size, in_msg.Type)) {
                DPRINTF(PrvDebug, "Status of new byte access check block : %#x :: %d\n",in_msg.LineAddress,
                        OptionalOwnAccessMetadata.accessToNewBytes(in_msg.PhysicalAddress, in_msg.Size, in_msg.Type));
                if (in_msg.Type == RubyRequestType:LD) {
                  trigger(Event:CH_PRV_LD,in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
                  // False Sharing: An instruction fetch request will be redirected to Icache due to request type
                  // resulting replacement of private block 
                } else {
                  trigger(Event:CH_PRV_ST,in_msg.LineAddress, L1Dcache_entry, TBEs[in_msg.LineAddress]);
                }
            } else if(is_valid(tbe) && tbe.isRMW_Read && (in_msg.Type == RubyRequestType:ST_RMW_Write)) {
              // FalseSharing: added to handle locked RMW n=in non-blocking style
              if (tbe.pendingRequest) {
                // FalseSharing: complete store and serve pending request
                if(tbe.pendingReqType == CoherenceRequestType:GETX ||
                  tbe.pendingReqType == CoherenceRequestType:UPGRADE) {
                    trigger(Event:Write_Store_PenX, in_msg.LineAddress,
                    L1Dcache_entry, TBEs[in_msg.LineAddress]);
                } else if(tbe.pendingReqType == CoherenceRequestType:GETS) {
                  trigger(Event:Write_Store_PenS, in_msg.LineAddress,
                    L1Dcache_entry, TBEs[in_msg.LineAddress]);
                }
                // FalseSharing: TODO: uncomment if an error for this 
                // else if (tbe.pendingReqType == CoherenceRequestType:INV_PRV) {
                  // Invalidation received before the data response
                  // trigger(Event:Write_Store_PenS, in_msg.LineAddress,
                  //  L1Dcache_entry, TBEs[in_msg.LineAddress]);
                //}
              } else {
                // FalseSharing: Since RMW_Read is completed, No pending request
                // Deallocate tbe
                trigger(Event:RMW_Write_Store, in_msg.LineAddress,L1Dcache_entry, TBEs[in_msg.LineAddress]);
              }
            } else {
              // The tag matches for the L1, so the L1 ask the L2 for it
              trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
                    L1Dcache_entry, TBEs[in_msg.LineAddress]);
            }
          } else {

            // Check to see if it is in the OTHER L1
            Entry L1Icache_entry := getL1ICacheEntry(in_msg.LineAddress);
            if (is_valid(L1Icache_entry)) {
              // FalseSharing: I-cache does not have PAM entry 
              // The block is in the wrong L1, put the request on the queue to the shared L2
              trigger(Event:L1_Replacement, in_msg.LineAddress,
                      L1Icache_entry, TBEs[in_msg.LineAddress]);
              DPRINTF(ProtocolTrace,"Requested block %#x in I-cache",in_msg.LineAddress);

            }

            if (L1Dcache.cacheAvail(in_msg.LineAddress)) {
              // L1 does't have the line, but we have space for it
              // in the L1 let's see if the L2 has it.
              trigger(mandatory_request_type_to_event(in_msg.Type), in_msg.LineAddress,
                      L1Dcache_entry, TBEs[in_msg.LineAddress]);
            } else {
              // No room in the L1, so we need to make room in the L1

              // Check if the line we want to evict is not locked
              Addr addr := L1Dcache.cacheProbe(in_msg.LineAddress);
              check_on_cache_probe(mandatoryQueue_in, addr);
              if (getState(TBEs[addr], getL1DCacheEntry(addr), addr) == State:PRV) {
                ++OptionalOwnAccessMetadata.prv_replacement;
                DPRINTF(PrvDebug,"Prv replacement block: %#x\n",in_msg.LineAddress);
              }
              if (getState(TBEs[addr], getL1DCacheEntry(addr), addr) == State:S
                  && OptionalOwnAccessMetadata.getMDCommBit(addr)) {
                trigger(Event:L1_Replacement_S, addr,
                        getL1DCacheEntry(addr), TBEs[addr]);
              } else {
                trigger(Event:L1_Replacement, addr,
                      getL1DCacheEntry(addr),
                      TBEs[addr]);
              }
            }
          }
        }
      }
    }
  }

  void enqueuePrefetch(Addr address, RubyRequestType type) {
      enqueue(optionalQueue_out, RubyRequest, 1) {
          out_msg.LineAddress := address;
          out_msg.Type := type;
          out_msg.AccessMode := RubyAccessMode:Supervisor;
      }
  }

  // ACTIONS
  action(a_issueGETS, "a", desc="Issue GETS") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;

        out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
        out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset
        // FalseSharing: reporting the instruction involved in Falsesharing
        if (report_pc) {
          out_msg.involvedInst := in_msg.ProgramCounter;
          out_msg.virtPkt := in_msg.pkt;
        }
      }
    }
  }

  action(pa_issuePfGETS, "pa", desc="Issue prefetch GETS") {
    peek(optionalQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETS;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;

        out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
        out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size
      }
    }
  }

  action(ai_issueGETINSTR, "ai", desc="Issue GETINSTR") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GET_INSTR;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;

        out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
        out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size
      }
    }
  }

  action(pai_issuePfGETINSTR, "pai",
         desc="Issue GETINSTR for prefetch request") {
      peek(optionalQueue_in, RubyRequest) {
          enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
              out_msg.addr := address;
              out_msg.Type := CoherenceRequestType:GET_INSTR;
              out_msg.Requestor := machineID;
              out_msg.Destination.add(
                  mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Prefetch := in_msg.Prefetch;
              out_msg.AccessMode := in_msg.AccessMode;

              out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
              out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size

              DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                      address, out_msg.Destination);
          }
      }
  }

  action(b_issueGETX, "b", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:GETX;
        out_msg.Requestor := machineID;
        DPRINTF(RubySlicc, "%s\n", machineID);
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;

        out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
        out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size
        // FalseSharing: reporting the instruction involved in Falsesharing
        if (report_pc) {
          out_msg.involvedInst := in_msg.ProgramCounter;
          out_msg.virtPkt := in_msg.pkt;
        }
      }
    }
  }

  action(pb_issuePfGETX, "pb", desc="Issue prefetch GETX") {
      peek(optionalQueue_in, RubyRequest) {
          enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
              out_msg.addr := address;
              out_msg.Type := CoherenceRequestType:GETX;
              out_msg.Requestor := machineID;
              DPRINTF(RubySlicc, "%s\n", machineID);

              out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));

              DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                      address, out_msg.Destination);
              out_msg.MessageSize := MessageSizeType:Control;
              out_msg.Prefetch := in_msg.Prefetch;
              out_msg.AccessMode := in_msg.AccessMode;

              out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
              out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size
          }
      }
  }

  action(c_issueUPGRADE, "c", desc="Issue GETX") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg,  l1_request_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceRequestType:UPGRADE;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
                address, out_msg.Destination);
        out_msg.MessageSize := MessageSizeType:Control;
        out_msg.Prefetch := in_msg.Prefetch;
        out_msg.AccessMode := in_msg.AccessMode;

        out_msg.Len := in_msg.Size; // FalseSharing: track no of requested bytes
        out_msg.PhyAddress := in_msg.PhysicalAddress; // FalseSharing: Required for find offset and size
        // FalseSharing: reporting the instruction involved in Falsesharing
        if (report_pc) {
          out_msg.involvedInst := in_msg.ProgramCounter;
          out_msg.virtPkt := in_msg.pkt;
        }
      }
    }
  }

  // FalseSharing: copy the metadata communication bit to response
  action(d_sendDataToRequestor, "d", desc="send data to requestor") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Data;

        // FalseSharing: persist metadata status for a gets
        out_msg.requireMetadata := in_msg.requireMetadata;
        if (in_msg.Type == CoherenceRequestType:GETS) {
          OptionalOwnAccessMetadata.updateMDCommBit(address, in_msg.requireMetadata);
        }
      }
    }
  }

  // FalseSharing: new action to respond to forwarded request from E state
  action(d_sendDataToRequestorE, "de", desc="send data to requestor") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Data;

        // FalseSharing: persist metadata status for a gets
        out_msg.requireMetadata := true;
        // getx and upgrade invalidate block
        if (in_msg.Type == CoherenceRequestType:GETS) {
          out_msg.requireMetadata := false;
          OptionalOwnAccessMetadata.updateMDCommBit(address,in_msg.requireMetadata);
        }
      }
    }
  }

  action(d2_sendDataToL2, "d2", desc="send data to the L2 cache because of M downgrade") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(dt_sendDataToRequestor_fromTBE, "dt", desc="send data to requestor") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:DATA;
        out_msg.DataBlk := tbe.DataBlk;
        out_msg.Dirty := tbe.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Data;
        // FalseSharing: copy the require metadata bit
        out_msg.requireMetadata := in_msg.requireMetadata;
      }
    }
  }

  action(d2t_sendDataToL2_fromTBE, "d2t", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(tbe));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := tbe.DataBlk;
      out_msg.Dirty := tbe.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Data;
    }
  }

  action(e_sendAckToRequestor, "e", desc="send invalidate ack to requestor (could be L2 or L1)") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
      }
    }
  }

  action(f_sendDataToL2, "f", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Data;
    }
  }

  action(ft_sendDataToL2_fromTBE, "ft", desc="send data to the L2 cache") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(tbe));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := tbe.DataBlk;
      out_msg.Dirty := tbe.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Data;
    }
  }

  action(fi_sendInvAck, "fi", desc="send data to the L2 cache") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:ACK;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Control;
        out_msg.AckCount := 1;
        out_msg.requireMetadata := in_msg.requireMetadata; 
      }
    }
  }

  action(forward_eviction_to_cpu, "\cc", desc="sends eviction information to the processor") {
    if (send_evictions) {
      DPRINTF(RubySlicc, "Sending invalidation for %#x to the CPU\n", address);
      sequencer.evictionCallback(address);
    }
  }

  action(g_issuePUTX, "g", desc="send data to the L2 cache") {
    enqueue(requestL1Network_out, RequestMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:PUTX;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Requestor:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      if (cache_entry.Dirty) {
        out_msg.MessageSize := MessageSizeType:Writeback_Data;
      } else {
        out_msg.MessageSize := MessageSizeType:Writeback_Control;
      }
      if(OptionalOwnAccessMetadata.getMDCommBit(address)) {
        out_msg.requireMetadata := true;
        APPEND_TRANSITION_COMMENT(" MD sent ");
        APPEND_TRANSITION_COMMENT(address);
      } else {
        out_msg.requireMetadata := false;
        APPEND_TRANSITION_COMMENT(" MD not sent ");
        APPEND_TRANSITION_COMMENT(address);
      }
    }
  }

  action(j_sendUnblock, "j", desc="send unblock to the L2 cache") {
    enqueue(unblockNetwork_out, ResponseMsg, to_l2_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:UNBLOCK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Control;
      DPRINTF(RubySlicc, "%#x\n", address);
    }
  }

  action(jj_sendExclusiveUnblock, "\j", desc="send unblock to the L2 cache") {
    enqueue(unblockNetwork_out, ResponseMsg, to_l2_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:EXCLUSIVE_UNBLOCK;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Control;
      DPRINTF(RubySlicc, "%#x\n", address);

    }
  }

  action(h_load_hit, "hd",
         desc="Notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Dcache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(h_ifetch_hit, "hi", desc="Notify sequencer the instruction fetch completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(cache_entry);
    sequencer.readCallback(address, cache_entry.DataBlk);
  }

  action(hx_load_hit, "hx", desc="Notify sequencer the load completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(address);
    L1Dcache.setMRU(address);
    sequencer.readCallback(address, cache_entry.DataBlk, true);
  }

  action(hh_store_hit, "\h", desc="Notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Dcache.setMRU(cache_entry);
    sequencer.writeCallback(address, cache_entry.DataBlk);
    cache_entry.Dirty := true;
  }

  action(hhx_store_hit, "\hx", desc="Notify sequencer that store completed.")
  {
    assert(is_valid(cache_entry));
    DPRINTF(RubySlicc, "%s\n", cache_entry.DataBlk);
    L1Icache.setMRU(address);
    L1Dcache.setMRU(address);
    sequencer.writeCallback(address, cache_entry.DataBlk, true);
    cache_entry.Dirty := true;
  }

  action(i_allocateTBE, "i", desc="Allocate TBE (isPrefetch=0, number of invalidates=0)") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.isPrefetch := false;
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
    // FalseSharing: Populate Physical Address and requested bytes
    peek(mandatoryQueue_in, RubyRequest) {
      tbe.bytesCount := in_msg.Size;
      tbe.PhyAddress := in_msg.PhysicalAddress;
      tbe.AccessMode := in_msg.AccessMode;
      tbe.Prefetch := in_msg.Prefetch;
      if(in_msg.Type == RubyRequestType:ST_RMW_Read) {
        tbe.isRMW_Read := true;
      }
    }
  }

  // FalseSharing: for allocating TBE without storing Phy Address
  action(i_allocateTBEModified, "im", desc="Allocate TBE, do not store physical address") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.isPrefetch := false;
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
  }

  // FalseSharing: allocate tbe and set flag for RMW_Read instruction
  action(i_allocateTBERMW, "ir", desc="Allocate TBE for RMW instruction") {
    check_allocate(TBEs);
    assert(is_valid(cache_entry));
    TBEs.allocate(address);
    set_tbe(TBEs[address]);
    tbe.isPrefetch := false;
    tbe.Dirty := cache_entry.Dirty;
    tbe.DataBlk := cache_entry.DataBlk;
    tbe.isRMW_Read := true;
    // FalseSharing: Populate Physical Address and requested bytes
    peek(mandatoryQueue_in, RubyRequest) {
      tbe.bytesCount := in_msg.Size;
      tbe.PhyAddress := in_msg.PhysicalAddress;
      tbe.AccessMode := in_msg.AccessMode;
      tbe.Prefetch := in_msg.Prefetch;
    }
  }

  action(k_popMandatoryQueue, "k", desc="Pop mandatory queue.") {
    mandatoryQueue_in.dequeue(clockEdge());
  }

  action(l_popRequestQueue, "l",
    desc="Pop incoming request queue and profile the delay within this virtual network") {
    Tick delay := requestL1Network_in.dequeue(clockEdge());
    profileMsgDelay(2, ticksToCycles(delay));
  }

  action(o_popIncomingResponseQueue, "o",
    desc="Pop Incoming Response queue and profile the delay within this virtual network") {
    Tick delay := responseL1Network_in.dequeue(clockEdge());
    profileMsgDelay(1, ticksToCycles(delay));
  }

  action(s_deallocateTBE, "s", desc="Deallocate TBE") {
    TBEs.deallocate(address);
    unset_tbe();
  }

  action(u_writeDataToL1Cache, "u", desc="Write data to cache") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(cache_entry));
      cache_entry.DataBlk := in_msg.DataBlk;
      cache_entry.Dirty := in_msg.Dirty;
    }
  }

  action(q_updateAckCount, "q", desc="Update ack count") {
    peek(responseL1Network_in, ResponseMsg) {
      assert(is_valid(tbe));
      tbe.pendingAcks := tbe.pendingAcks - in_msg.AckCount;
      APPEND_TRANSITION_COMMENT(in_msg.AckCount);
      APPEND_TRANSITION_COMMENT(" p: ");
      APPEND_TRANSITION_COMMENT(tbe.pendingAcks);
      APPEND_TRANSITION_COMMENT(" Sender: ");
      APPEND_TRANSITION_COMMENT(in_msg.Sender);
    }
  }

  action(ff_deallocateL1CacheBlock, "\f", desc="Deallocate L1 cache block.  Sets the cache to not present, allowing a replacement in parallel with a fetch.") {
    if (L1Dcache.isTagPresent(address)) {
      L1Dcache.deallocate(address);
      // FalseSharing: to manage a one-to-one mapping of block
      // here perform deallocation
      OptionalOwnAccessMetadata.removeOptionalMetadataEntry(address);
    } else {
      L1Icache.deallocate(address);
    }
    unset_cache_entry();
  }

  action(oo_allocateL1DCacheBlock, "\o", desc="Set L1 D-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L1Dcache.allocate(address, new Entry));
      OptionalOwnAccessMetadata.addOptionalMetadataEntry(address);
    }
  }
  // FalseSharing: No PAM entry allocation for Icache block
  action(pp_allocateL1ICacheBlock, "\p", desc="Set L1 I-cache tag equal to tag of block B.") {
    if (is_invalid(cache_entry)) {
      set_cache_entry(L1Icache.allocate(address, new Entry));
    }
  }

  action(z_stallAndWaitMandatoryQueue, "\z", desc="Stall and wait the L1 mandatory request queue") {
    stall_and_wait(mandatoryQueue_in, address);
  }

  action(z_stallAndWaitOptionalQueue, "\pz", desc="Stall and wait the L1 prefetch request queue") {
    stall_and_wait(optionalQueue_in, address);
  }

  action(z_stallAndWaitRequestQueue, "\rz", desc="Stall and wait the L1 request queue") {
    stall_and_wait(requestL1Network_in, address);
  }

  // FalseSharing: Modify TBE entry to hold a fwd req
  action(i_modifytbe, "mt", desc="modify tbe on receiving fwd Request") {
    peek(requestL1Network_in, RequestMsg) {
      assert(is_valid(tbe));
      tbe.pendingRequest := true;
      tbe.pendingRequestor := in_msg.Requestor;
      tbe.pendingReqType := in_msg.Type;
      tbe.metadataAction := in_msg.requireMetadata;
    }
  }

  action(u_updateMetadataAction, "umt", desc="update the require metadata bit in tbe") {
    peek(requestL1Network_in, RequestMsg) {
      assert(is_valid(tbe));
      tbe.metadataAction := in_msg.requireMetadata;
    }
  }

  // FalseSharing: handle pending request using tbe
  action(s_servePendingGETX, "spx", desc="complete the outstanding GETX/UPGRADE request") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      assert(is_valid(tbe));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(tbe.pendingRequestor);
      out_msg.MessageSize := MessageSizeType:Response_Data;
      // FalseSharing: copy the metadata action for request MD
      out_msg.requireMetadata := tbe.metadataAction;
    }
  }

  // FalseSharing: handle pending request using tbe
  action(s_servePendingGETS, "sps", desc="complete the outstanding GETS request") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      assert(is_valid(tbe));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender := machineID;
      out_msg.Destination.add(tbe.pendingRequestor);
      out_msg.MessageSize := MessageSizeType:Response_Data;
      // FalseSharing: copy the metadata action for request MD
      out_msg.requireMetadata := tbe.metadataAction;
    }
  }

  action(kd_wakeUpDependents, "kd", desc="wake-up dependents") {
    wakeUpBuffers(address);
  }

  action(uu_profileInstMiss, "\uim", desc="Profile the demand miss") {
      ++L1Icache.demand_misses;
  }

  action(uu_profileInstHit, "\uih", desc="Profile the demand hit") {
      ++L1Icache.demand_hits;
  }

  action(uu_profileDataMiss, "\udm", desc="Profile the demand miss") {
      ++L1Dcache.demand_misses;
  }

  action(uu_profileDataHit, "\udh", desc="Profile the demand hit") {
      ++L1Dcache.demand_hits;
  }

  action(po_observeHit, "\ph", desc="Inform the prefetcher about the hit") {
      peek(mandatoryQueue_in, RubyRequest) {
          if (cache_entry.isPrefetch) {
              prefetcher.observePfHit(in_msg.LineAddress);
              cache_entry.isPrefetch := false;
          }
      }
  }

  action(po_observeMiss, "\po", desc="Inform the prefetcher about the miss") {
      peek(mandatoryQueue_in, RubyRequest) {
          if (enable_prefetch) {
              prefetcher.observeMiss(in_msg.LineAddress, in_msg.Type);
          }
      }
  }

  action(ppm_observePfMiss, "\ppm",
         desc="Inform the prefetcher about the partial miss") {
      peek(mandatoryQueue_in, RubyRequest) {
          prefetcher.observePfMiss(in_msg.LineAddress);
      }
  }

  action(pq_popPrefetchQueue, "\pq", desc="Pop the prefetch request queue") {
      optionalQueue_in.dequeue(clockEdge());
  }

  action(mp_markPrefetched, "mp", desc="Set the isPrefetch flag") {
      assert(is_valid(cache_entry));
      cache_entry.isPrefetch := true;
  }

  // FalseSharing: Action for OWN ACCESS Metadata
  //UpdateAccessMetadata: true := Read, false := Write
  action(fs_addRdOwnAccessMetadata, 'arom', desc="add new entry in own access table") {
    // update PAM entry only if data present in D-cache
    Entry currEntry := getL1ICacheEntry(address);
    if (L1Icache.isTagPresent(address) || (is_valid(currEntry))) {
    } else if(L1Dcache.isTagPresent(address)) {
      //OptionalOwnAccessMetadata.addOptionalMetadataEntry(address);
      OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress, TBEs[address].bytesCount, true);
    } else {
      APPEND_TRANSITION_COMMENT("No MD update for block in NP or Icache");
      assert(false);
    }
  }

  // FalseSharing:
  action(fs_addWrOwnAccessMetadata, 'awom', desc="add new entry in own access table") {
    //DPRINTF(OptionalMetadata,"New Entry for  Block: %#x \n", address);
    // update PAM entry only if data present in D-cache
    if(L1Dcache.isTagPresent(address)) {
      //OptionalOwnAccessMetadata.addOptionalMetadataEntry(address);
      OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress,
                        TBEs[address].bytesCount, false);
    } else {
      bool blockInICacheOrNP := false;
      APPEND_TRANSITION_COMMENT("No MD update for block in NP or Icache");
      assert(blockInICacheOrNP);
    }
  }

  //UpdateAccessMetadata: true := Read, false := Write
  action(fs_updateRdPAM, 'urp', desc="update LD byte access in PAM") {
    //DPRINTF(OptionalMetadata,"New Entry for  Block: %#x \n", address);
    OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress, TBEs[address].bytesCount, true);
  }

  // FalseSharing:
  action(fs_updateWrPAM, 'uwp', desc="update ST byte access in PAM") {
    //DPRINTF(OptionalMetadata,"New Entry for  Block: %#x \n", address);
    OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress,
                        TBEs[address].bytesCount, false);
  }

  // FalseSharing: Own Access MD update := RD/WR request(Cache hit)
  action(fs_updateOwnAccessMetadata,"uow",desc="update own access metadata on Hit") {
    // update PAM entry only if data present in D-cache
    if(L1Dcache.isTagPresent(address)) {
      peek(mandatoryQueue_in,RubyRequest) {
        //DPRINTF(OptionalMetadata, "Access Metadata Update for Addr: %#x \n", in_msg.PhysicalAddress);
        if ( in_msg.Type == RubyRequestType:LD) {
          OptionalOwnAccessMetadata.updateOptionalMetadataEntry(in_msg.PhysicalAddress, in_msg.Size, true);
        } else if (in_msg.Type == RubyRequestType:IFETCH) {
          // FalseSharing: NO OPERATION
        } else {
          // in_msg.Type == ST, RMW-Read, or Write
          OptionalOwnAccessMetadata.updateOptionalMetadataEntry(in_msg.PhysicalAddress, in_msg.Size, false);
        }
      }
    }
  }

  // FalseSharing: Action for transition from trasient state
  action(fs_updateOwnAccessMetadataTBERD,"umtr",desc="update own access metadata using TBE Response MSG") {
    //DPRINTF(OptionalMetadata, "Access Metadata Update for Addr: %#x\n", TBEs[address].PhyAddress);
    // update PAM entry only if data present in D-cache
    if(L1Dcache.isTagPresent(address)) {
      OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress,
                            TBEs[address].bytesCount, true);
    }
  }

  // FalseSharing:
  action(fs_updateOwnAccessMetadataTBEWR,"umtw",desc="update own access metadata using TBE Response MSG") {
    //DPRINTF(OptionalMetadata, "Access Metadata Update for Addr: %#x\n", TBEs[address].PhyAddress);
    // update PAM entry only if data present in D-cache
    if(L1Dcache.isTagPresent(address)) {
      OptionalOwnAccessMetadata.updateOptionalMetadataEntry(TBEs[address].PhyAddress,
                                                          TBEs[address].bytesCount, false);
    }
  }

  // FalseSharing:
  action(fs_deallocateAccessMD, "dowm", desc="remove an entry for own access metadata on Replacement") {
    //DPRINTF(OptionalMetadata, "Access metadata removed for Block: %#x\n", address);
    OptionalOwnAccessMetadata.removeOptionalMetadataEntry(address);
  }

  // FalseSharing: reset access metadata on privatization init, updated block with LLC
  action(fs_resetAccessMetadata, "rowm", desc="reset own access metadata on privatization") {
    //DPRINTF(OptionalMetadata,"Access metadata reset for block %#x\n",address);
    OptionalOwnAccessMetadata.resetMetadataEntry(address);
  }

  // FalseSharing: action to persist metadata communication bit
  action(fs_updateMetadatabit, "umb", desc="preserve MD bit in PAM to handle communication on eviction") {
    // update PAM entry only if data present in D-cache
    if(L1Dcache.isTagPresent(address)) {
      peek(responseL1Network_in, ResponseMsg) {
        OptionalOwnAccessMetadata.updateMDCommBit(in_msg.addr, in_msg.requireMetadata);
        APPEND_TRANSITION_COMMENT(" MD comm bit:");
        APPEND_TRANSITION_COMMENT(in_msg.requireMetadata);
      }
    }
  }

  // FalseSharing: unused action to send access metadata
  action(fs_sendAccessMD, "soam", desc="send Own Access metadata to GlobalACT") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      //assert(is_valid(tbe));
      out_msg.addr := address;
      if (OptionalOwnAccessMetadata.validMetadataEntry(address)) {
        out_msg.Type := CoherenceResponseType:GA_OWA;
      } else {
        out_msg.Type := CoherenceResponseType:GA_DMD;
      }
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Metadata; // FalseSharing: Use defined MsgType for metadata
      out_msg.OptionalAccessMetadata := OptionalOwnAccessMetadata.getBlockAccess(address);
    }
  }


  // FalseSharing: send MD if the MD bit in request message is set
  action(fs_sendAccessMDReq, "somr", desc="send own access md based on request") {
    peek(requestL1Network_in, RequestMsg) {
      // FalseSharing: send metadata only if request MD bit is set
      if(in_msg.requireMetadata) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          //assert(is_valid(tbe));
          out_msg.addr := address;
          Entry currEntry := getL1DCacheEntry(address);
          // FalseSharing: populate variable based on whether the block entry exists or not 
          if (OptionalOwnAccessMetadata.validMetadataEntry(address) && is_valid(currEntry)) {
            out_msg.Type := CoherenceResponseType:GA_OWA;
            out_msg.OptionalAccessMetadata := OptionalOwnAccessMetadata.getBlockAccess(address);
            out_msg.MessageSize := MessageSizeType:Metadata;
          } else {
            out_msg.Type := CoherenceResponseType:GA_DMD;
            out_msg.MessageSize := MessageSizeType:Response_Control;
          }
          out_msg.Sender := machineID;
          out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                              l2_select_low_bit, l2_select_num_bits, intToID(0)));
        }
      }
    }
  }

  // FalseSharing: action to decide whether AcT requireMetadata based on TBE
  action(fs_sendAccessMDTBE, "somt", desc="send own access md based on tbe status") {
    // FalseSharing: send metadata only if metadata action bit is true
    if(tbe.metadataAction) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        //assert(is_valid(tbe));
        out_msg.addr := address;
        if (OptionalOwnAccessMetadata.validMetadataEntry(address)) {
          out_msg.Type := CoherenceResponseType:GA_OWA;
        } else {
          out_msg.Type := CoherenceResponseType:GA_DMD;
        }
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Metadata; // Use already defined MsgType
        out_msg.OptionalAccessMetadata := OptionalOwnAccessMetadata.getBlockAccess(address);
      }
    }
  }

  // FalseSharing: A control MD msg for invalidation received in a transient state
  action(fs_sendDummyMD, "sdm", desc="send dummy metadata to GlobalACT") {
    // FalseSharing: send only if metadata bit is set
    peek(requestL1Network_in, RequestMsg) {
      if(in_msg.requireMetadata) {
        enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
          //assert(is_valid(tbe));
          out_msg.addr := address;
          out_msg.Type := CoherenceResponseType:GA_DMD;
          out_msg.Sender := machineID;
          out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                              l2_select_low_bit, l2_select_num_bits, intToID(0)));
          out_msg.MessageSize := MessageSizeType:Response_Control; // Use already defined MsgType
        }
      }
    }
  }

  // FalseSharing: access metadata on eviction
  action(fs_sendMDOnEviction, "some", desc="send Own Access metadata on eviction") {
    // FalseSharing: if MD bit in PAM set, send MD 
    if (L1Dcache.isTagPresent(address) && OptionalOwnAccessMetadata.getMDCommBit(address)) {
      ++OptionalOwnAccessMetadata.evc_owner;
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        //assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:GA_OWE;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Metadata; // Use already defined MsgType
        out_msg.OptionalAccessMetadata := OptionalOwnAccessMetadata.getBlockAccess(address);
      }
      APPEND_TRANSITION_COMMENT(" MD sent: ");
      APPEND_TRANSITION_COMMENT(OptionalOwnAccessMetadata.getMDCommBit(address));
    }
  }

  // FalseSharing: access metadata on eviction
  action(fs_sendMDOnEvictionS, "smes", desc="send Own Access metadata on eviction from S state") {
    // FalseSharing: if MD bit in PAM set, send MD 
    if (OptionalOwnAccessMetadata.getMDCommBit(address)) {
      ++OptionalOwnAccessMetadata.evc_shared;
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        //assert(is_valid(tbe));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:GA_EMD;
        out_msg.Sender := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                            l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Metadata; // Use already defined MsgType
        out_msg.OptionalAccessMetadata := OptionalOwnAccessMetadata.getBlockAccess(address);
      }
    }
  }

  // FalseSharing: Mark block private
  action(fs_markBlockPrivate, "fsmp", desc="Mark the block private") {
    // FalseSharing: No need to peek.
    //Since State is S or M cache_entry will exist
    //The equivalent c++ code uses continue without loop stmt
    //Do not use peek unless using a in_msg attribute
    assert(is_valid(cache_entry));
    cache_entry.isPrivatized := true;
    DPRINTF(PrvDebug, "Block privatized %#x\n", address);
  }

  // FalseSharing: As Dir/LLC has updated metadata information dont send OWN MD
  // sent on termination of privatization
  action(fs_sendWBDataonINV, "fswi", desc="writeback data to the L2 cache on INV") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:GA_DATA;
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Sender:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      if (cache_entry.Dirty) {
        out_msg.MessageSize := MessageSizeType:Writeback_Data;
      } else {
        out_msg.MessageSize := MessageSizeType:Writeback_Control;
      }
    }
  }

  // FalseSharing: Do not own block send control message
  // Race: received INV to terminate privatization before data privatization message response
  // utilize in race condition
  action(fs_sendWBonINV, "fsw", desc="writeback data to the L2 cache on INV") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      // assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:GA_DATA_CTRL;
      out_msg.Dirty := false;
      out_msg.Sender:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Control;
    }
  }

  // FalseSharing: new action for sending a control msg on receiving
  // invalidation privatization for block not-present in cache
  action(fs_sendWB, "fsnp", desc="writeback data to the L2 cache for block not present") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      // assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:GA_DATA_CTRL_NP;
      out_msg.Dirty := false;
      out_msg.Sender:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Writeback_Control;
    }
  }


  // FalseSharing:
  action(fs_sendWBData, "fswr", desc="writeback data on replacement") {
    enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
      assert(is_valid(cache_entry));
      out_msg.addr := address;
      out_msg.Type := CoherenceRequestType:PRV_PUTX; // differentiate an eviction after privatization
      out_msg.DataBlk := cache_entry.DataBlk;
      out_msg.Dirty := cache_entry.Dirty;
      out_msg.Requestor:= machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      if (cache_entry.Dirty) {
        out_msg.MessageSize := MessageSizeType:Writeback_Data;
      } else {
        out_msg.MessageSize := MessageSizeType:Writeback_Control;
      }
    }
  }

  // FalseSharing:
  action(fs_reissueRequest,"fsrr", desc="Reissue a request on ") {
    enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
      assert(is_valid(tbe));

      out_msg.addr := address; //FalseSharing:
      out_msg.Type := CoherenceRequestType:GETX;
      out_msg.Requestor := machineID;
      DPRINTF(RubySlicc, "%s\n", machineID);
      // FalseSharing: change address to use field addr from TBE 
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                        l2_select_low_bit, l2_select_num_bits, intToID(0)));
      DPRINTF(RubySlicc, "address: %#x, destination: %s\n",
              address, out_msg.Destination);
      out_msg.MessageSize := MessageSizeType:Control;
      out_msg.AccessMode := tbe.AccessMode;
      out_msg.Len := tbe.bytesCount;
      out_msg.PhyAddress := tbe.PhyAddress;
      out_msg.AccessMode := tbe.AccessMode;
      out_msg.Prefetch := tbe.Prefetch;
    }
  }

  // FalseSharing: Forwarded request :To respond data block to L1 requestor
  // FalseSharing: unused now, privatization data response send by LLC, prevent concurrent access
  action(fs_sendDataToRequestor, "fssr", desc="Send updated data to requestor") {
    peek(requestL1Network_in, RequestMsg) {
      enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
        assert(is_valid(cache_entry));
        out_msg.addr := address;
        out_msg.Type := CoherenceResponseType:GA_DATA;
        out_msg.DataBlk := cache_entry.DataBlk;
        out_msg.Dirty := cache_entry.Dirty;
        out_msg.Sender := machineID;
        out_msg.Destination.add(in_msg.Requestor);
        out_msg.MessageSize := MessageSizeType:Response_Data;
      }
    }
  }

  // FalseSharing: Request to LLC/Dir on access to newer byte
  action(fs_sendConflictCheckRequest, "fscr", desc="send out a conflict check request") {
    peek(mandatoryQueue_in, RubyRequest) {
      enqueue(requestL1Network_out, RequestMsg, l1_request_latency) {
        assert(is_valid(cache_entry));
        // FalseSharing: Can update the replacement statistic here also        
        out_msg.addr := address;
        // FalseSharing: Check for LD,
        // Else need to check for ST, RMW_Read and RMW_Write also
        if(in_msg.Type == RubyRequestType:LD || in_msg.Type == RubyRequestType:IFETCH) {
          out_msg.Type := CoherenceRequestType:GA_CHCK_LD;
        } else { // RMW_Read or RMW_Write to be treat as ST
          out_msg.Type := CoherenceRequestType:GA_CHCK_ST;
        }
        out_msg.PhyAddress := in_msg.PhysicalAddress;
        out_msg.Len := in_msg.Size;
        out_msg.Requestor := machineID;
        out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
        out_msg.MessageSize := MessageSizeType:Request_Control;
      }
    }
  }

  action(fs_prvLD, "por", desc="profile the read to a privatize line") {
    ++OptionalOwnAccessMetadata.prv_rd;
  }

  action(fs_prvST, "pow", desc="profile the writes to a privatize line") {
    ++OptionalOwnAccessMetadata.prv_wr;
  }

  // update last access tick for block on sending conflict access check 
  action(fs_updateTickOnConflictCheck, "utcd", desc="update the replacement policy tick on sending conflict check request") {
    assert(is_valid(cache_entry));
    L1Icache.setMRU(address);
    L1Dcache.setMRU(address);
  }

  // To handle race between replacement and trigger privatization
  // send control message to inform LLC about eviction
  action(fs_sendCtrlToL2_PRV, "scp", desc="send data to the L2 cache on privatization") {
    enqueue(responseL1Network_out, ResponseMsg, l1_response_latency) {
      out_msg.addr := address;
      out_msg.Type := CoherenceResponseType:CTRL_PRV;
      out_msg.Dirty := false;
      out_msg.Sender := machineID;
      out_msg.Destination.add(mapAddressToRange(address, MachineType:L2Cache,
                          l2_select_low_bit, l2_select_num_bits, intToID(0)));
      out_msg.MessageSize := MessageSizeType:Response_Control;
    }
  }

  action(fs_IfetchToMblock, "itom", desc="debug action to track the Ifetch request to a M block") {
    APPEND_TRANSITION_COMMENT(" Ifetch request for a modified block");
  }
  //*****************************************************
  // TRANSITIONS
  //*****************************************************

  // Transitions for Load/Store/Replacement/WriteBack from transient states
  // FalseSharing: new event for locked rmw read
  transition({IS, IM, IS_I, M_I, SM, SINK_WB_ACK,S_I}, {Load, Ifetch, Store, L1_Replacement, RMW_Read_Store}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({PF_IS, PF_IS_I}, {Store, L1_Replacement, RMW_Read_Store}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({PF_IM, PF_SM}, {Load, Ifetch, L1_Replacement}) {
    z_stallAndWaitMandatoryQueue;
  }

  transition({IS, IM, IS_I, M_I, SM, SINK_WB_ACK, PF_IS, PF_IS_I, PF_IM, PF_SM}, PF_L1_Replacement) {
    z_stallAndWaitOptionalQueue;
  }

  // Transitions from Idle
  transition({NP,I}, {L1_Replacement, PF_L1_Replacement}) {
    ff_deallocateL1CacheBlock;
  }

  transition({S,E,M,IS,IM,SM,IS_I,PF_IS_I,M_I,SINK_WB_ACK,PF_IS,PF_IM},
             {PF_Load, PF_Store, PF_Ifetch}) {
      pq_popPrefetchQueue;
  }

  transition({NP,I}, Load, IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    a_issueGETS;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;
  }

  transition({NP,I}, PF_Load, PF_IS) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    pa_issuePfGETS;
    pq_popPrefetchQueue;
  }

  transition(PF_IS, Load, IS) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition(PF_IS_I, Load, IS_I) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition(PF_IS_I, Ifetch, IS_I) {
    uu_profileInstMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  // FalseSharing: an additional state for instruction request
  // prevent allocation of PAM entry, only implementation level change
  transition({NP,I}, Ifetch, IS) {
    pp_allocateL1ICacheBlock;
    i_allocateTBE;
    ai_issueGETINSTR;
    uu_profileInstMiss;
    po_observeMiss;
    k_popMandatoryQueue;
  }

  transition({NP,I}, PF_Ifetch, PF_IS) {
    pp_allocateL1ICacheBlock;
    i_allocateTBE;
    pai_issuePfGETINSTR;
    pq_popPrefetchQueue;
  }

  // We proactively assume that the prefetch is in to
  // the instruction cache
  transition(PF_IS, Ifetch, IS) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  // FalseSharing: might reduce the number even by treating RMW_Read as Store
  // bit set based on request type
  transition({NP,I}, {Store,RMW_Read_Store}, IM) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    b_issueGETX;
    uu_profileDataMiss;
    po_observeMiss;
    k_popMandatoryQueue;
  }

  // FalseSharing: All transition remains same, except a flag for RMW_read set in tbe
  // Same as store in I state transition
  //transition({NP,I}, RMW_Read_Store, IM) {
  //  oo_allocateL1DCacheBlock;
  //  i_allocateTBE; // FalseSharing: Ealier using the i_allocateTBERMW
  //  b_issueGETX;
  //  uu_profileDataMiss;
  //  po_observeMiss;
  //  k_popMandatoryQueue;
  //}

  //False Sharing: Later add transition in for RMW_store
  transition({NP,I}, PF_Store, PF_IM) {
    oo_allocateL1DCacheBlock;
    i_allocateTBE;
    pb_issuePfGETX;
    pq_popPrefetchQueue;
  }

  transition(PF_IM, Store, IM) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition(PF_SM, Store, SM) {
    uu_profileDataMiss;
    ppm_observePfMiss;
    k_popMandatoryQueue;
  }

  transition({NP, I}, Inv) {
    fi_sendInvAck;
    fs_sendDummyMD; // FalseSharing: MD bit set in invalidation request, send dummy MD
    l_popRequestQueue;
  }

  // Transitions from Shared

  // Update Own Access Metadata
  transition({S,E,M}, Load) {
    h_load_hit;
    uu_profileDataHit;
    fs_updateOwnAccessMetadata; // FalseSharing: Proc GlobalACT
    po_observeHit;
    k_popMandatoryQueue;
  }

  // FalseSharing: do not update PAM for Instr fetch request
  transition({S,E,M}, Ifetch) {
    h_ifetch_hit;
    uu_profileInstHit;
    //fs_IfetchToMblock;
    po_observeHit;
    k_popMandatoryQueue;
  }

  transition(S, {Store,RMW_Read_Store}, SM) {
    i_allocateTBE;
    c_issueUPGRADE;
    uu_profileDataMiss;
    k_popMandatoryQueue;
  }

  // FalseSharing: transition for setting flag for RMW
  //  the tbe allocation check for Request type and set RMW bit
  //transition(S, RMW_Read_Store, SM) {
  //  i_allocateTBE; // Earlier: using i_allocateTBERMW
  //  c_issueUPGRADE;
  //  uu_profileDataMiss;
  //  k_popMandatoryQueue;
  //}

 // FalseSharing: do not send MD on replacement
  transition(S, {L1_Replacement, PF_L1_Replacement}, I) {
    forward_eviction_to_cpu;
    ff_deallocateL1CacheBlock;
  }

  transition(S, L1_Replacement_S, S_I) {
    forward_eviction_to_cpu;
    i_allocateTBEModified;
    fs_sendMDOnEvictionS;
    //fs_deallocateAccessMD; // FalseSharing: MD entry removed along with Cache Block
    ff_deallocateL1CacheBlock;
  }

  transition(S, Inv, I) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    fs_sendAccessMDReq; // FalseSharing: send MD on block invalidation
    //fs_deallocateAccessMD; // FalseSharing: deallocate Entry with block removal only
    l_popRequestQueue;
  }

  // Transitions from Exclusive

  //Cache hit update metadata
  transition({E,M}, {Store, RMW_Read_Store}, M) {
    hh_store_hit;
    uu_profileDataHit;
    fs_updateOwnAccessMetadata; // FalseSharing:
    po_observeHit;
    k_popMandatoryQueue;
  }

  // FalseSharing: new transition to handle scenario with no pending request 
  transition(M, RMW_Write_Store ,M) {
    hh_store_hit;
    uu_profileDataHit;
    fs_updateOwnAccessMetadata;
    po_observeHit;
    s_deallocateTBE; // FalseSharing: Deallocate tbe entry as no pending request to service
    k_popMandatoryQueue;
  }

  // FalseSharing: new transition to handle pending GETX request after RMW_Write completion.
  transition(M, Write_Store_PenX, I) {
    hh_store_hit;
    uu_profileDataHit;
    po_observeHit; // FalseSharing: Stat for prefetch 
    fs_updateOwnAccessMetadata; // FalseSharing: update PAM
    forward_eviction_to_cpu; // notify CPU about eviction
    s_servePendingGETX;     // FalseSharing: service pending request now
    fs_sendAccessMDTBE; // FalseSharing: true sharing will not request metadata
    //fs_deallocateAccessMD; // FalseSharing: remove entry with cache block
    s_deallocateTBE;
    k_popMandatoryQueue;
  }

  // FalseSharing: new transition to handle pending GETS request after RMW_Write completion.
  transition(M, Write_Store_PenS, S) {
    hh_store_hit;
    uu_profileDataHit;
    po_observeHit; // FalseSharing: Stat for prefetch request
    fs_updateOwnAccessMetadata; // FalseSharing: update PAM
    s_servePendingGETS; // FalseSharing: transient buffer entry hold the Requestor
    d2_sendDataToL2;     // FalseSharing: service pending request now
    fs_sendAccessMDTBE; // FalseSharing: fix for metadata count mismatch
    s_deallocateTBE;
    k_popMandatoryQueue;
  }

  // FalseSharing: do not send MD on block replacement
  transition(E, {L1_Replacement, PF_L1_Replacement}, M_I) {
    // silent E replacement??
    forward_eviction_to_cpu;
    i_allocateTBEModified; // FalseSharing: use modified allocation of transient buffer entry
    g_issuePUTX;   // send data, but hold in case forwarded request
    fs_sendMDOnEviction; // FalseSharing: 
    ff_deallocateL1CacheBlock;
  }

  // Update INV counter and send metadata
  // scenario: invalidation arrives before a forwarded GetS
  transition(E, Inv, I) {
    // don't send data
    forward_eviction_to_cpu;
    fi_sendInvAck;
    fs_sendAccessMDReq; // FalseSharing: send MD if MD bit is set
    //fs_deallocateAccessMD; // FalseSharing:
    l_popRequestQueue;
  }

  // FalseSharing: since block is invalidated, no MD on eviction
  transition(E, Fwd_GETX, I) {
    forward_eviction_to_cpu;
    d_sendDataToRequestor;
    fs_sendAccessMDReq; // FalseSharing: send MD if bit is set on intervention
    //fs_deallocateAccessMD; // FalseSharing:
    l_popRequestQueue;
  }

  // Permission Downgrade
  transition(E, Fwd_GETS, S) {
    d_sendDataToRequestorE;
    d2_sendDataToL2;
    fs_sendAccessMDReq; // FalseSharing: send MD if bit is set
    l_popRequestQueue;
  }

  // Permission Downgrade
  transition(E, Fwd_GET_INSTR, S) {
    d_sendDataToRequestor;
    d2_sendDataToL2;
    l_popRequestQueue;
  }
  // Transitions from Modified

  // Replacement evict metadata
  // FalseSharing: no metadata on eviction
  transition(M, {L1_Replacement, PF_L1_Replacement}, M_I) {
    forward_eviction_to_cpu;
    i_allocateTBEModified; // FalseSharing: use new allocate tbe
    g_issuePUTX;   // send data, but hold in case forwarded request
    fs_sendMDOnEviction; // FalseSharing:
    ff_deallocateL1CacheBlock;
  }

  transition(M_I, WB_Ack, I) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(M, Inv, I) {
    forward_eviction_to_cpu;
    f_sendDataToL2;
    fs_sendAccessMDReq; // FalseSharing:
    l_popRequestQueue;
  }

  transition(M_I, Inv, SINK_WB_ACK) {
    ft_sendDataToL2_fromTBE;
    fs_sendDummyMD;
    l_popRequestQueue;
  }

  // FalseSharing: Do not store MD bit as block is invalidated
  // Permission Downgrade
  transition(M, Fwd_GETX, I) {
    forward_eviction_to_cpu;
    d_sendDataToRequestor;
    fs_sendAccessMDReq; // FalseSharing:
    l_popRequestQueue;
  }

  // Permission Downgrade
  // FalseSharing: store the require Metadata bit status
  transition(M, Fwd_GETS, S) {
    d_sendDataToRequestor;
    d2_sendDataToL2;
    fs_sendAccessMDReq; // FalseSharing:
    l_popRequestQueue;
  }

  transition(M, Fwd_GET_INSTR, S) {
    d_sendDataToRequestor;
    d2_sendDataToL2;
    l_popRequestQueue;
  }

  transition(M_I, Fwd_GETX, SINK_WB_ACK) {
    dt_sendDataToRequestor_fromTBE;
    fs_sendDummyMD; // FalseSharing: control message to sync MD count
    l_popRequestQueue;
  }

  transition(M_I, {Fwd_GETS, Fwd_GET_INSTR}, SINK_WB_ACK) {
    dt_sendDataToRequestor_fromTBE;
    d2t_sendDataToL2_fromTBE;
    fs_sendDummyMD; // FalseSharing: control message to sync MD count
    l_popRequestQueue;
  }

  // Transitions from IS
  // FalseSharing: adding state IS_PA for handling invalidation
  transition({IS, IS_I, IS_PA}, Inv, IS_I) {
    fi_sendInvAck;
    fs_sendDummyMD; // FalseSharing: control message to sync MD count
    l_popRequestQueue;
  }

  // FalseSharing: if plan to use the prefetcher add MD message
  transition({PF_IS, PF_IS_I}, Inv, PF_IS_I) {
    fi_sendInvAck;
    l_popRequestQueue;
  }


  // LD request completed
  transition({IS,IS_PA}, Data_all_Acks, S) {
    u_writeDataToL1Cache;
    hx_load_hit;
    fs_addRdOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_IS, Data_all_Acks, S) {
    u_writeDataToL1Cache;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(IS_I, Data_all_Acks, I) {
    u_writeDataToL1Cache;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_IS_I, Data_all_Acks, I) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition({IS,IS_PA}, DataS_fromL1, S) {
    u_writeDataToL1Cache;
    j_sendUnblock;
    hx_load_hit;
    fs_addRdOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_IS, DataS_fromL1, S) {
    u_writeDataToL1Cache;
    j_sendUnblock;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: discuss MD update and persist the metadata communication bit
  transition(IS_I, DataS_fromL1, I) {
    u_writeDataToL1Cache;
    j_sendUnblock;
    hx_load_hit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_IS_I, DataS_fromL1, I) {
    j_sendUnblock;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Directory is blocked when sending exclusive data
  // FalseSharing: Do not set PAM REQ_MD bit
  // FalseSharing: If block is evicted no sharing, later intervention would request MD 
  transition(IS_I, Data_Exclusive, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    //jj_sendExclusiveUnblock; // FalseSharing: Directory is not blocked now
    fs_addRdOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // directory is blocked when sending exclusive data
  transition(PF_IS_I, Data_Exclusive, E) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition({IS,IS_PA}, Data_Exclusive, E) {
    u_writeDataToL1Cache;
    hx_load_hit;
    //jj_sendExclusiveUnblock;
    fs_addRdOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_IS, Data_Exclusive, E) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Transitions from IM
  transition(IM, Inv, IM) {
    fi_sendInvAck;
    fs_sendDummyMD; // FalseSharing: control message to sync MD count
    l_popRequestQueue;
  }

  // FalseSharing: send metadata if plan to use prefetcher
  transition({PF_IM, PF_SM}, Inv, PF_IM) {
    fi_sendInvAck;
    l_popRequestQueue;
  }

  transition(IM, Data, SM) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  transition(PF_IM, Data, PF_SM) {
    u_writeDataToL1Cache;
    q_updateAckCount;
    o_popIncomingResponseQueue;
  }

  // FalseSharing: Dir sends response, non blocking transition
  transition({IM, IM_I,IM_PA}, Data_all_Acks, M) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    // jj_sendExclusiveUnblock; Don't require since SS>MT and IM > MT transition
    fs_addWrOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition({IM, IM_I, IM_PA}, Data_all_Acks_RMW, M) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    //jj_sendExclusiveUnblock;
    fs_addWrOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    // s_deallocateTBE; //FalseSharing: Do not deallocate transient buffer entry (store forwarded request info)
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Prv cache response, require unblock
  // Added  new transient state invalidation received in upgrade request 
  transition({IM, IM_I, IM_PA}, Data_all_Acks_Unblock, M) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    jj_sendExclusiveUnblock;
    fs_addWrOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Prv cache response, require unblock
  transition({IM,IM_I, IM_PA}, Data_all_Acks_Unblock_RMW, M) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    jj_sendExclusiveUnblock;
    fs_addWrOwnAccessMetadata; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    // s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // Added  new transient state invalidation received in upgrade request
  // FalseSharing: added to handle a unhandled transition error 
  // verify once more the sequence of event
  // transition({IS_PA}, Data_all_Acks_Unblock, S) {
    // u_writeDataToL1Cache;
    // check if changing this remove the assert failure
    // //hhx_store_hit;// FalseSharing: should be a load hit, bcoz state is IS_PA, a pending load
    // h_load_hit;
    // j_sendUnblock;
    // fs_addWrOwnAccessMetadata; // FalseSharing:
    // fs_updateMetadatabit; // FalseSharing:
    // s_deallocateTBE;
    // o_popIncomingResponseQueue;
    // kd_wakeUpDependents;
  //}


  // FalseSharing: Directory sends response, non-blocking transition
  // Need to add DeFT metadata action if using Prefetching
  transition(PF_IM, Data_all_Acks, M) {
    u_writeDataToL1Cache;
    //jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Prv cache response, require unblocking
  transition(PF_IM, Data_all_Acks_Unblock, M) {
    u_writeDataToL1Cache;
    jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // transitions from SM
  transition(SM, Inv, IM) {
    forward_eviction_to_cpu;
    fi_sendInvAck;
    fs_sendAccessMDReq; // FalseSharing: required due to race between two upgrade request
    l_popRequestQueue;
  }

  transition({SM, IM, PF_SM, PF_IM,IM_PA}, Ack) {
    q_updateAckCount;
    fs_updateMetadatabit; //FalseSharing: 
    o_popIncomingResponseQueue;
  }

  transition(SM, Ack_all, M) {
    hhx_store_hit;
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    fs_updateMetadatabit;
    //jj_sendExclusiveUnblock; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Do not deallocate tbe (store information of forwarded request)
  transition(SM, Ack_all_RMW, M) {
    hhx_store_hit;
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(PF_SM, Ack_all, M) {
    //jj_sendExclusiveUnblock;
    s_deallocateTBE;
    mp_markPrefetched;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(SINK_WB_ACK, Inv){
    fi_sendInvAck;
    fs_sendDummyMD;
    l_popRequestQueue;
  }

  transition(SINK_WB_ACK, WB_Ack, I){
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Additonal transition for race when
  // received a Fwd_GetX while in SM state
  // We can't serve requestright now, may result in livelock
  // SCENARIO: core 1 ST will not complete and it may retry and core2 may
  // receive forwarded request and its action might not complete
  // TODO: finalize the request IM_RTRY forwarded request
  // FalseSharing: IM_PA unhandled fwd request 
  transition({SM, IM, IS, IM_I,IS_PA, IM_PA}, {Fwd_GETX,Fwd_GETS,Fwd_GET_INSTR}) {
    i_modifytbe;
    l_popRequestQueue;
  }

  // FalseSharing: Additional transition to handle pending GETX/UPGRADE in SM state
  transition(SM,Pen_GetX,I) {
    hhx_store_hit; // FalseSharing: Sequencer is notified store completed.
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    forward_eviction_to_cpu; // notify CPU about eviction
    s_servePendingGETX; // FalseSharing: transient buffer entry hold the Requestor
    fs_sendAccessMDTBE; // FalseSharing:
    //fs_deallocateAccessMD; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue; // FalseSharing: Required as Ack_All is processed
    kd_wakeUpDependents;
  }

  // FalseSharing: Additional transition to handle pending GETS in SM state on receiving Ack_All
  // Send WB data to LLC
  transition(SM,Pen_GetS,S) {
    hhx_store_hit; // FalseSharing: Sequencer is notified store completed.
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    fs_updateMetadatabit;
    s_servePendingGETS; // FalseSharing: transient buffer entry hold the Requestor
    d2_sendDataToL2;
    fs_sendAccessMDTBE;
    s_deallocateTBE;
    o_popIncomingResponseQueue; // FalseSharing: Required as Ack_All is processed
    kd_wakeUpDependents;
  }

  // FalseSharing: handle forwarded getx in transient state.
  transition({IM,IM_PA,IM_I}, Pen_GetX, I) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    forward_eviction_to_cpu; // notify CPU about eviction
    s_servePendingGETX;
    fs_sendAccessMDTBE; // FalseSharing:
    //fs_deallocateAccessMD; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: handle forwarded gets in transient state
  // Resolve the forwarded request issue in ESTM-rbtree benchmark
  transition({IM,IM_I,IM_PA}, Pen_GetS, S) {
    u_writeDataToL1Cache;
    hhx_store_hit;
    fs_updateOwnAccessMetadataTBEWR; // FalseSharing:
    fs_updateMetadatabit; // FalseSharing:
    s_servePendingGETS; // FalseSharing: transient buffer entry holds the Requestor
    d2_sendDataToL2;
    fs_sendAccessMDTBE; // FalseSharing: send MD based on transient buffer entry  bit status
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: handle forwarded getx due to exclusive response by LLC
  // The block is invalidated due to pending GetX therefore do not update metadata communication bit
  transition({IS,IS_PA}, Pen_GetX, I) {
    u_writeDataToL1Cache;
    hx_load_hit;
    fs_updateOwnAccessMetadataTBERD; // FalseSharing:
    forward_eviction_to_cpu; // notify CPU about eviction
    s_servePendingGETX;
    fs_sendAccessMDTBE; // FalseSharing: send MD based on transient buffer entry bit status
    //fs_deallocateAccessMD; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: TODO: possible for IS_PA to receive the forwarded request
  // FalseSharing: handle frwd GetS due to exclusive response by LLC
  transition({IS, IS_PA}, Pen_GetS, S) {
    u_writeDataToL1Cache;
    hx_load_hit;
    fs_updateOwnAccessMetadataTBERD; // FalseSharing:
    fs_updateMetadatabit;
    s_servePendingGETS; // FalseSharing: transient buffer entry hold the Requestor
    d2_sendDataToL2; // FalseSharing: required as directory marks core as owner
    fs_sendAccessMDTBE; // FalseSharing: send MD based on tbe bit
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: LLC send acknowledge to mark block private.
  transition(S, TR_PRV, PRV) {
    fs_markBlockPrivate;
    fs_sendAccessMDReq;    // FalseSharing: Send out own_access_metadata for update serve as ACK also
    fs_resetAccessMetadata;
    l_popRequestQueue;
  }

  // FalseSharing: Core owner of block, request triggering privatization forwarded by LLC
  transition(M, TR_PRV, PRV) {
    fs_markBlockPrivate;
    d2_sendDataToL2;//// FalseSharing: send data to LLC for update
    fs_sendAccessMDReq; // FalseSharing: send own_access_metadata for update
    fs_resetAccessMetadata;
    l_popRequestQueue;
  }

  // FalseSharing: do not forward 
  transition(E, TR_PRV, PRV) {
    fs_markBlockPrivate;
    d2_sendDataToL2; // FalseSharing: send data to LLC for update
    fs_sendAccessMDReq; // FalseSharing: send own_access_metadata for update
    fs_resetAccessMetadata;
    l_popRequestQueue;
  }

  // FalseSharing: LLC responds with the private cache block after privatization
  transition(IS, Data_PRV, PRV) {
    u_writeDataToL1Cache;
    hx_load_hit;
    fs_prvLD;
    fs_addRdOwnAccessMetadata; // FalseSharing:
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: protocol race trigger privatization reaches before gets response
  transition(IS, TR_PRV, IS_PRV) {
    u_updateMetadataAction;
    l_popRequestQueue;
  }

  // FalseSharing: protocol race trigger privatization reaches before gets response
  transition(IM, TR_PRV, IM_PRV) {
    u_updateMetadataAction;
    l_popRequestQueue;
  }

  // FalseSharing: TODO: Discuss the corresponding Action
  transition({NP,I}, TR_PRV) {
    fs_sendCtrlToL2_PRV;
    l_popRequestQueue;
  }

  // FalseSharing: send control msg denoting eviction at L1 
  transition(M_I, TR_PRV) {
  //  l_popRequestQueue;
    z_stallAndWaitRequestQueue;
  }

  // FalseSharing: wait for eviction acknowledgment response 
  transition(S_I, TR_PRV) {
  //  l_popRequestQueue;
    z_stallAndWaitRequestQueue;
  }

  // FalseSharing: gets response  arrives, complete load and send access metadata to directory
  transition(IS_PRV, Data_all_Acks, PRV) {
    u_writeDataToL1Cache;
    hx_load_hit;
    fs_prvLD;
    fs_addRdOwnAccessMetadata; // FalseSharing:
    fs_sendAccessMDTBE;
    fs_resetAccessMetadata;
    fs_markBlockPrivate;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: getx response  arrives, complete store and send access metadata to directory
  // TODO: Discuss two scenario:
  // 1. data respone for private arrive after intiate privatization
  // 2. getX response arrive after trigger privatization
  transition(IM_PRV, Data_all_Acks, PRV) {
    u_writeDataToL1Cache;
    hh_store_hit;
    fs_prvST;
    fs_addWrOwnAccessMetadata; // FalseSharing:
    fs_sendAccessMDTBE;
    fs_resetAccessMetadata;
    fs_markBlockPrivate;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: LLC responds with private blocks
  transition(IM, Data_PRV, PRV) {
    u_writeDataToL1Cache;
    hh_store_hit;
    fs_prvST;
    fs_markBlockPrivate;
    fs_addWrOwnAccessMetadata;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: Since block is already in S State
  // the initiate privatization message may arrive either due to upgrade request of the same core
  // or  getx/gets/ upgrade request of other core  
  transition(SM, TR_PRV, SM_P) {
    fs_sendAccessMDReq;
    fs_resetAccessMetadata;
    l_popRequestQueue;
  }

  // FalseSharing: complete the pending store
  transition(SM_P, Data_PRV, PRV) {
    fs_markBlockPrivate;
    hh_store_hit;
    fs_prvST;
    fs_addWrOwnAccessMetadata;
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: getX, getS will be hit perform a sanity conflict detection check
  // FalseSharing: uncomment the fs_updateOwnAccessMetadata action
  transition(PRV,{Store, RMW_Read_Store}) {
    // FalseSharing: check performed before triggering event
    // Only update accessMD here and PFS status can be setup during check.
    //fs_updateOwnAccessMetadata; // FalseSharing: ACT
    hh_store_hit;
    fs_prvST;
    uu_profileDataHit;
    po_observeHit;
    k_popMandatoryQueue;
  }

  // FalseSharing: Since a repetitive load to same byte,
  // no point in updating PAM entry save energy
  transition(PRV, Load) {
    fs_updateOwnAccessMetadata; // FalseSharing: Proc GlobalACT
    h_load_hit;
    fs_prvLD;
    uu_profileDataHit;
    po_observeHit;
    k_popMandatoryQueue;
  }

  // FalseSharing: uncomment the fs_updateOwnAccessMetadata action
  //transition(PRV,Ifetch) {
  //  h_ifetch_hit;
  //  fs_prvLD;
  //  uu_profileInstHit;
  //  fs_updateOwnAccessMetadata; // FalseSharing: Proc GlobalACT
  //  po_observeHit;
  //  k_popMandatoryQueue;
  //}

  // FalseSharing: Highly contended Line, Replacement will be occur rarely
  transition(PRV, L1_Replacement, M_I) {
    forward_eviction_to_cpu;
    i_allocateTBEModified; // use new tbe allocation
    fs_sendWBData;   // send data
    ff_deallocateL1CacheBlock;
  }

  // FalseSharing: Inform Directory to perform access conflict detection
  //Directory will sned out ACK if no conflict, or terminate privatization
  //now intermediate transient state for  prv can receive termination signal.
  transition(PRV, CH_PRV_ST, PRV_CHK_ST) {
    i_allocateTBE; // FalseSharing: store the block address and accessed byte
    fs_updateTickOnConflictCheck;
    fs_sendConflictCheckRequest;
    k_popMandatoryQueue; // FalseSharing: remove request from Queue
    //z_stallAndWaitMandatoryQueue;// FalseSharing: stall queue untill conflict detection completed.
  }

  transition(PRV, CH_PRV_LD, PRV_CHK_LD) {
    i_allocateTBE; // FalseSharing: store the block address and accessed byte
    fs_updateTickOnConflictCheck;
    fs_sendConflictCheckRequest;
    k_popMandatoryQueue; // FalseSharing: remove request from Queue
    // z_stallAndWaitMandatoryQueue;// FalseSharing: stall queue untill conflict detection completed.
  }

  // FalseSharing: if no conflict at LLC
  transition(PRV_CHK_LD, NC_PRV, PRV) {
    hx_load_hit;
    fs_prvLD;
    fs_updateRdPAM;
    // fs_addRdOwnAccessMetadata; //FalseSharing: incorrect action for existing entry
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: if no conflict at LLC
  transition(PRV_CHK_ST, NC_PRV, PRV) {
    hh_store_hit;
    fs_prvST;
    fs_updateWrPAM;
    // fs_addWrOwnAccessMetadata; //FalseSharing: incorrect action for existing entry
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: LLC sends INV if either conflict detection fails for own
  //  request or other request
  transition(PRV, Inv_PRV, PRV_IB) {
    forward_eviction_to_cpu; // FalseSharing: inform CPU about block eviction 
    i_allocateTBEModified; // use new tbe allocation
    fs_sendWBDataonINV; // FalseSharing: the LLC will update block based on whether dirty bit is set or not
    //ff_deallocateL1CacheBlock;
    l_popRequestQueue;
  }

  // FalseSharing: An upgrade request by core invalidation for termination
  transition(SM_P, Inv_PRV, IM_PD) { // FalseSharing: IM_PAA can be use to differentiate
    forward_eviction_to_cpu;
    fs_sendWBDataonINV; // FalseSharing: the LLC will update block based on whether dirty bit is set or not
    l_popRequestQueue;
  }

  // FalseSharing: uncomment if using state IM_PAA in above transition
  //transition(IM_PAA, Data_PRV, IM_RTRY) {
  //  o_popIncomingResponseQueue;
  //}

  // FalseSharing: invalidation to terminate privatizaton arrive before data message or privatization message
  transition(IM, Inv_PRV, IM_PD) {
    fs_sendWBonINV;
    l_popRequestQueue;
  }

  // FalseSharing: Protocol-race block in NP state,
  // Scenario: Core is sharer/owner, evicts the block, privatization trigggered by LLC
  // TODO: scenario can arise
  // uncomment if a unhandled transition error is reported for the block 
  //transition(NP, Inv_PRV, NP) {
  //  fs_sendWB;
  //  l_popRequestQueue;
  //}

  transition(IS, Inv_PRV, IS_PD) {
    fs_sendWBonINV;
    l_popRequestQueue;
  }

  // FalseSharing: Protocol race between eviction and invalidation request by LLC
  // Once eviction data reaches LLC, the core will be removed from the sharer list
  // and core's update will be merged in the LLC block.
  // send the control msg to sync the acknowledgment count
  transition(M_I, Inv_PRV)
  {
    fs_sendWBonINV;
    l_popRequestQueue;
  }

  transition(IM_PD, Data_PRV, IM_RTRY) {
    o_popIncomingResponseQueue;
  }

  transition(IS_PD, Data_PRV, IS_RTRY) {
    o_popIncomingResponseQueue;
  }

  // FalseSharing: Ack for WB on termination arrived reissue the request 
  transition(IM_RTRY, WB_Ack, IM) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }

  // FalseSharing: receive ack for write back
  transition(IM_PD, WB_Ack, IM_I) {
    o_popIncomingResponseQueue;
  }

  transition(IS_PD, WB_Ack, IS_PDI) {
    o_popIncomingResponseQueue;
  }

  // FalseSharing: receive data privatization response 
  transition(IM_I, Data_PRV, IM) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }

  transition(IS_PDI, Data_PRV, IS) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }

  // FalseSharing: check if possible to 
  //transition(IM_PD, Data_Exclusive, M) {
  //  u_writeDataToL1Cache;
  //  hhx_store_hit;
  //  fs_addWrOwnAccessMetadata; // FalseSharing:
  //  s_deallocateTBE;
  //  o_popIncomingResponseQueue;
  //  kd_wakeUpDependents;
  //}

  // FalseSharing: on invalidation immediately respond with WB msg
  transition(PRV_CHK_ST, Inv_PRV, IM_PR) {
    fs_sendWBDataonINV;
    l_popRequestQueue;
  }
  
  transition(IM_PR,WB_Ack,IM_PA) {
    o_popIncomingResponseQueue;
  }

  // FalseSharing: received no conflict acknow , reissue request after wb ack
  transition(IM_PR,NC_PRV, IM_RTRY) {
    o_popIncomingResponseQueue;
  }

  // Add new request to handle invalidation
  transition(PRV_CHK_LD, Inv_PRV, IS_PR) {
    fs_sendWBDataonINV;
    l_popRequestQueue;
  }

  // FalseSharing: received no conflict acknow , reissue request after wb ack
  transition(IS_PR,NC_PRV, IS_RTRY) {
    o_popIncomingResponseQueue;
  }

  transition(IS_PR,WB_Ack,IS_PA) {
    o_popIncomingResponseQueue;
  }

  // FalseSharing: Ack for WB on termination arrived reissue the request 
  transition(IS_RTRY, WB_Ack, IS) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }

  // FalseSharing: conflict ack reissue request 
  transition(IS_PA, NC_PRV, IS) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }
  // FalseSharing: conflict ack, reissue request
  transition(IM_PA, NC_PRV, IM) {
    fs_reissueRequest;
    o_popIncomingResponseQueue;
  }

  // FalseSharing: receives write back ack from LLC
  transition(PRV_IB, WB_Ack, I) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  // FalseSharing: stall the request from the core.
  // No instruction fetch request should be served
  transition({PRV_IB,PRV_CHK_ST, PRV_CHK_LD}, {Load, Store, RMW_Read_Store}) {
    //Stall the queue
    z_stallAndWaitMandatoryQueue;
  }

  //  FalseSharing: eviction MD from S state
  transition(S_I, Ack_EMD, I) {
    s_deallocateTBE;
    o_popIncomingResponseQueue;
    kd_wakeUpDependents;
  }

  transition(S_I, Inv) {
    fi_sendInvAck;
    fs_sendDummyMD; // FalseSharing: control message to sync MD count
    l_popRequestQueue;
  }

  transition({PRV_IB,PRV_CHK_ST,PRV_CHK_LD,SM_P,PRV_IBW,IS_PRV,IM_PRV,IM_RTRY,IM_PAA,IM_PD,IM_I,IM_PR,IM_PA,IS_PR,IS_PA,IS_RTRY},L1_Replacement) {
    z_stallAndWaitMandatoryQueue;
  }
}
